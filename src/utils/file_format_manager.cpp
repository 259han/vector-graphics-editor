#include "file_format_manager.h"
#include "../core/graphic_item.h"
#include "../utils/logger.h"
#include <QFile>
#include <QXmlStreamWriter>
#include <QSvgGenerator>
#include <QPainter>
#include <QDataStream>
#include <QGraphicsItem>
#include <QGraphicsItemGroup>
#include <QTemporaryFile>
#include <QBuffer>
#include <QFileInfo>

// 静态常量定义
const QString FileFormatManager::CVG_EXTENSION = ".cvg";
const QString FileFormatManager::CVG_MIME_TYPE = "application/x-custom-vector-graphics";

// 单例实现
FileFormatManager& FileFormatManager::getInstance() {
    static FileFormatManager instance;
    return instance;
}

// 保存为自定义矢量格式
bool FileFormatManager::saveToCustomFormat(const QString& filePath, QGraphicsScene* scene) {
    if (!scene) {
        Logger::error("FileFormatManager::saveToCustomFormat: 场景为空");
        return false;
    }

    QFile file(filePath);
    if (!file.open(QIODevice::WriteOnly)) {
        Logger::error(QString("FileFormatManager::saveToCustomFormat: 无法打开文件 %1: %2")
            .arg(filePath).arg(file.errorString()));
        return false;
    }

    QDataStream stream(&file);
    
    // 写入文件标识符和版本
    stream << QString("CVG"); // 文件标识
    stream << CVG_VERSION;    // 版本号
    
    // 写入场景信息
    stream << scene->sceneRect();
    stream << scene->backgroundBrush();

    // 获取并序列化所有图形项
    QList<QGraphicsItem*> items = scene->items();
    if (!serializeGraphicItems(stream, items)) {
        file.close();
        return false;
    }
    
    // 序列化图层信息
    if (!serializeLayers(stream, scene)) {
        file.close();
        return false;
    }

    file.close();
    return true;
}

// 从自定义矢量格式加载
bool FileFormatManager::loadFromCustomFormat(const QString& filePath, QGraphicsScene* scene, 
                                           std::function<void(Graphic::GraphicType, const QPointF&, const QPen&, const QBrush&, 
                                                            const std::vector<QPointF>&, double, const QPointF&)> itemFactory) {
    if (!scene) {
        Logger::error("FileFormatManager::loadFromCustomFormat: 场景为空");
        return false;
    }

    QFile file(filePath);
    if (!file.open(QIODevice::ReadOnly)) {
        Logger::error(QString("FileFormatManager::loadFromCustomFormat: 无法打开文件 %1: %2")
            .arg(filePath).arg(file.errorString()));
        return false;
    }

    QDataStream stream(&file);
    
    // 读取并验证文件标识和版本
    QString fileId;
    qint32 version;
    stream >> fileId;
    stream >> version;
    
    if (fileId != "CVG") {
        Logger::error(QString("FileFormatManager::loadFromCustomFormat: 无效的文件格式 %1").arg(fileId));
        file.close();
        return false;
    }
    
    if (version > CVG_VERSION) {
        Logger::error(QString("FileFormatManager::loadFromCustomFormat: 不支持的文件版本 %1").arg(version));
        file.close();
        return false;
    }
    
    // 清空当前场景
    scene->clear();
    
    // 读取场景信息
    QRectF sceneRect;
    QBrush backgroundBrush;
    stream >> sceneRect;
    stream >> backgroundBrush;
    
    scene->setSceneRect(sceneRect);
    scene->setBackgroundBrush(backgroundBrush);
    
    // 反序列化图形项
    if (!deserializeGraphicItems(stream, scene, itemFactory)) {
        file.close();
        return false;
    }
    
    // 反序列化图层信息
    if (!deserializeLayers(stream, scene)) {
        file.close();
        return false;
    }

    file.close();
    return true;
}

// 导出为SVG格式
bool FileFormatManager::exportToSVG(const QString& filePath, QGraphicsScene* scene, const QSize& size) {
    if (!scene) {
        Logger::error("FileFormatManager::exportToSVG: 场景为空");
        return false;
    }
    
    QSize exportSize = size.isValid() ? size : scene->sceneRect().size().toSize();
    
    QSvgGenerator generator;
    generator.setFileName(filePath);
    generator.setSize(exportSize);
    generator.setViewBox(QRect(0, 0, exportSize.width(), exportSize.height()));
    generator.setTitle("Vector Graphics Editor Export");
    generator.setDescription("Generated by Custom Vector Graphics Editor");
    
    QPainter painter;
    if (!painter.begin(&generator)) {
        Logger::error("FileFormatManager::exportToSVG: 无法初始化SVG画笔");
        return false;
    }
    
    // 绘制背景（如果不是透明的）
    if (scene->backgroundBrush() != Qt::NoBrush) {
        painter.fillRect(QRect(0, 0, exportSize.width(), exportSize.height()), scene->backgroundBrush());
    }
    
    // 渲染场景内容到SVG
    scene->render(&painter, QRectF(), scene->sceneRect(), Qt::KeepAspectRatio);
    
    painter.end();
    return true;
}

// 序列化图形项辅助方法
bool FileFormatManager::serializeGraphicItems(QDataStream& stream, const QList<QGraphicsItem*>& items) {
    // 写入图形项数量
    stream << (qint32)items.size();
    
    // 序列化每个图形项
    for (auto item : items) {
        auto* graphicItem = dynamic_cast<GraphicItem*>(item);
        if (!graphicItem) continue;
        
        // 写入图形类型
        stream << (qint32)graphicItem->getGraphicType();
        
        // 写入位置
        stream << graphicItem->pos();
        
        // 写入画笔
        stream << graphicItem->getPen();
        
        // 写入画刷
        stream << graphicItem->getBrush();
        
        // 写入旋转
        stream << (qreal)graphicItem->rotation();
        
        // 写入缩放
        stream << graphicItem->getScale();
        
        // 写入Z值
        stream << (qreal)graphicItem->zValue();
        
        // 写入点集
        auto points = graphicItem->getClipboardPoints();
        stream << (qint32)points.size();
        for (const auto& point : points) {
            stream << point;
        }
        
        // 写入是否可见
        stream << graphicItem->isVisible();
        
        // 写入是否可移动
        stream << graphicItem->isMovable();
        
        // 写入自定义数据
        // TODO: 如果需要，这里可以扩展保存更多自定义数据
    }
    
    return stream.status() == QDataStream::Ok;
}

// 反序列化图形项辅助方法
bool FileFormatManager::deserializeGraphicItems(QDataStream& stream, QGraphicsScene* scene,
                            std::function<void(Graphic::GraphicType, const QPointF&, const QPen&, const QBrush&, 
                                              const std::vector<QPointF>&, double, const QPointF&)> itemFactory) {
    // 读取图形项数量
    qint32 itemCount;
    stream >> itemCount;
    
    // 反序列化每个图形项
    for (qint32 i = 0; i < itemCount; ++i) {
        // 读取图形类型
        qint32 type;
        stream >> type;
        Graphic::GraphicType graphicType = static_cast<Graphic::GraphicType>(type);
        
        // 读取位置
        QPointF position;
        stream >> position;
        
        // 读取画笔
        QPen pen;
        stream >> pen;
        
        // 读取画刷
        QBrush brush;
        stream >> brush;
        
        // 读取旋转
        qreal rotation;
        stream >> rotation;
        
        // 读取缩放
        QPointF scale;
        stream >> scale;
        
        // 读取Z值
        qreal zValue;
        stream >> zValue;
        
        // 读取点集
        qint32 pointCount;
        stream >> pointCount;
        std::vector<QPointF> points;
        points.reserve(pointCount);
        
        for (qint32 j = 0; j < pointCount; ++j) {
            QPointF point;
            stream >> point;
            points.push_back(point);
        }
        
        // 读取是否可见
        bool visible;
        stream >> visible;
        
        // 读取是否可移动
        bool movable;
        stream >> movable;
        
        // 使用工厂函数创建图形对象
        itemFactory(graphicType, position, pen, brush, points, rotation, scale);
    }
    
    return stream.status() == QDataStream::Ok;
}

// 序列化图层信息
bool FileFormatManager::serializeLayers(QDataStream& stream, QGraphicsScene* scene) {
    // 在当前版本中，我们只简单地保存Z顺序
    // 未来可以扩展支持真正的图层功能
    
    // 写入图层数量（目前为1，表示无图层）
    stream << (qint32)1;
    
    return stream.status() == QDataStream::Ok;
}

// 反序列化图层信息
bool FileFormatManager::deserializeLayers(QDataStream& stream, QGraphicsScene* scene) {
    // 读取图层数量
    qint32 layerCount;
    stream >> layerCount;
    
    // 目前不做任何特殊处理，因为我们只有一个图层
    
    return stream.status() == QDataStream::Ok;
} 