#include "file_format_manager.h"
#include "../core/graphic_item.h"
#include "../core/flowchart_connector_item.h"
#include "../utils/logger.h"
#include "../utils/scene_utils.h"
#include <QFile>
#include <QXmlStreamWriter>
#include <QSvgGenerator>
#include <QPainter>
#include <QDataStream>
#include <QGraphicsItem>
#include <QGraphicsItemGroup>
#include <QTemporaryFile>
#include <QBuffer>
#include <QFileInfo>

// 静态常量定义
const QString FileFormatManager::CVG_EXTENSION = ".cvg";
const QString FileFormatManager::CVG_MIME_TYPE = "application/x-custom-vector-graphics";

// 单例实现
FileFormatManager& FileFormatManager::getInstance() {
    static FileFormatManager instance;
    return instance;
}

// 保存为自定义矢量格式
bool FileFormatManager::saveToCustomFormat(const QString& filePath, QGraphicsScene* scene) {
    if (!scene) {
        Logger::error("FileFormatManager::saveToCustomFormat: 场景为空");
        return false;
    }

    // 保存前遍历并打印所有QGraphicsItem的类型
    QList<QGraphicsItem*> items = scene->items();
    Logger::debug(QString("FileFormatManager::saveToCustomFormat: 保存前场景共有%1个图元").arg(items.size()));
    for (auto* item : items) {
        if (auto* gi = dynamic_cast<GraphicItem*>(item)) {
            Logger::debug(QString("FileFormatManager::saveToCustomFormat: 图元 type=%1").arg(gi->getGraphicType()));
        } else {
            Logger::debug("FileFormatManager::saveToCustomFormat: 图元 非GraphicItem");
        }
    }

    QFile file(filePath);
    if (!file.open(QIODevice::WriteOnly)) {
        Logger::error(QString("FileFormatManager::saveToCustomFormat: 无法打开文件 %1: %2")
            .arg(filePath).arg(file.errorString()));
        return false;
    }

    QDataStream stream(&file);
    
    // 写入文件标识符和版本
    stream << QString("CVG"); // 文件标识
    stream << CVG_VERSION;    // 版本号
    
    // 写入场景信息
    stream << scene->sceneRect();
    stream << scene->backgroundBrush();

    // 获取并序列化所有图形项
    if (!serializeGraphicItems(stream, items)) {
        file.close();
        return false;
    }
    
    // 序列化图层信息
    if (!serializeLayers(stream, scene)) {
        file.close();
        return false;
    }

    file.close();
    return true;
}

// 从自定义矢量格式加载
bool FileFormatManager::loadFromCustomFormat(const QString& filePath, QGraphicsScene* scene, 
    std::function<GraphicItem*(Graphic::GraphicType, const QPointF&, const QPen&, const QBrush&, 
        const std::vector<QPointF>&, double, const QPointF&)> itemFactory,
    ConnectionManager* connectionManager,
    ConnectionPointOverlay* connectionOverlay,
    SelectionManager* selectionManager) {
    if (!scene) {
        Logger::error("FileFormatManager::loadFromCustomFormat: 场景为空");
        return false;
    }

    QFile file(filePath);
    if (!file.open(QIODevice::ReadOnly)) {
        Logger::error(QString("FileFormatManager::loadFromCustomFormat: 无法打开文件 %1: %2")
            .arg(filePath).arg(file.errorString()));
        return false;
    }

    QDataStream stream(&file);
    
    // 读取并验证文件标识和版本
    QString fileId;
    qint32 version;
    stream >> fileId;
    stream >> version;
    
    if (fileId != "CVG") {
        Logger::error(QString("FileFormatManager::loadFromCustomFormat: 无效的文件格式 %1").arg(fileId));
        file.close();
        return false;
    }
    
    if (version > CVG_VERSION) {
        Logger::error(QString("FileFormatManager::loadFromCustomFormat: 不支持的文件版本 %1").arg(version));
        file.close();
        return false;
    }
    
    // 清空当前场景
    SceneUtils::clearScene(scene, nullptr, connectionManager, connectionOverlay, selectionManager);
    
    // 读取场景信息
    QRectF sceneRect;
    QBrush backgroundBrush;
    stream >> sceneRect;
    stream >> backgroundBrush;
    
    scene->setSceneRect(sceneRect);
    scene->setBackgroundBrush(backgroundBrush);
    
    // 反序列化图形项
    if (!deserializeGraphicItems(stream, scene, itemFactory, connectionManager, connectionOverlay, selectionManager)) {
        file.close();
        Logger::error("FileFormatManager::loadFromCustomFormat: 反序列化图形项失败");
        return false;
    }
    
    // 反序列化图层信息
    if (!deserializeLayers(stream, scene)) {
        file.close();
        Logger::error("FileFormatManager::loadFromCustomFormat: 反序列化图层信息失败");
        return false;
    }

    file.close();
    return true;
}

// 导出为SVG格式
bool FileFormatManager::exportToSVG(const QString& filePath, QGraphicsScene* scene, const QSize& size) {
    if (!scene) {
        Logger::error("FileFormatManager::exportToSVG: 场景为空");
        return false;
    }
    
    QSize exportSize = size.isValid() ? size : scene->sceneRect().size().toSize();
    
    QSvgGenerator generator;
    generator.setFileName(filePath);
    generator.setSize(exportSize);
    generator.setViewBox(QRect(0, 0, exportSize.width(), exportSize.height()));
    generator.setTitle("Vector Graphics Editor Export");
    generator.setDescription("Generated by Custom Vector Graphics Editor");
    
    QPainter painter;
    if (!painter.begin(&generator)) {
        Logger::error("FileFormatManager::exportToSVG: 无法初始化SVG画笔");
        return false;
    }
    
    // 绘制背景（如果不是透明的）
    if (scene->backgroundBrush() != Qt::NoBrush) {
        painter.fillRect(QRect(0, 0, exportSize.width(), exportSize.height()), scene->backgroundBrush());
    }
    
    // 渲染场景内容到SVG
    scene->render(&painter, QRectF(), scene->sceneRect(), Qt::KeepAspectRatio);
    
    painter.end();
    return true;
}

// 序列化图形项辅助方法
bool FileFormatManager::serializeGraphicItems(QDataStream& stream, const QList<QGraphicsItem*>& items) {
    // 统计所有GraphicItem（包括连接器）
    QList<QGraphicsItem*> graphicItems;
    for (auto* item : items) {
        if (dynamic_cast<GraphicItem*>(item)) {
            graphicItems.append(item);
        }
    }
    
    Logger::debug(QString("FileFormatManager::serializeGraphicItems: 开始序列化，共有%1个图元需要序列化").arg(graphicItems.size()));
    stream << (qint32)graphicItems.size();
    
    // 序列化所有图形项（不再区分连接器）
    for (auto* item : graphicItems) {
        auto* graphicItem = static_cast<GraphicItem*>(item);
        Logger::debug(QString("FileFormatManager::serializeGraphicItems: 序列化图元，类型=%1").arg(graphicItem->getGraphicType()));
        graphicItem->serialize(stream);
    }
    
    Logger::debug(QString("FileFormatManager::serializeGraphicItems: 序列化完成，流状态=%1").arg(stream.status()));
    return stream.status() == QDataStream::Ok;
}

// 辅助函数：跳过一个图元的数据块
static void skipOneGraphicItem(QDataStream& stream) {
    int type;
    stream >> type;
    Logger::debug(QString("FileFormatManager::skipOneGraphicItem: 跳过一个图元，类型=%1").arg(type));
    QPointF pos;
    QPen pen;
    QBrush brush;
    double rotation;
    QPointF scale;
    bool visible, enabled;
    qreal z;
    stream >> pos >> pen >> brush >> rotation >> scale >> visible >> enabled >> z;
    qint32 pointCount;
    stream >> pointCount;
    Logger::debug(QString("FileFormatManager::skipOneGraphicItem: 跳过点集，数量=%1").arg(pointCount));
    for (int i = 0; i < pointCount; ++i) {
        QPointF pt;
        stream >> pt;
    }
    qint32 connectionPointCount;
    stream >> connectionPointCount;
    Logger::debug(QString("FileFormatManager::skipOneGraphicItem: 跳过连接点，数量=%1").arg(connectionPointCount));
    for (int i = 0; i < connectionPointCount; ++i) {
        QPointF pt;
        stream >> pt;
    }
    // 跳过FlowchartBaseItem等子类字段（如有）
    bool textVisible;
    QString text;
    QFont textFont;
    QColor textColor;
    QString id;
    QString uuid;
    stream >> textVisible >> text >> textFont >> textColor >> id >> uuid;
    Logger::debug("FileFormatManager::skipOneGraphicItem: 跳过图元结束");
}

// 反序列化图形项辅助方法
bool FileFormatManager::deserializeGraphicItems(QDataStream& stream, QGraphicsScene* scene,
    std::function<GraphicItem*(Graphic::GraphicType, const QPointF&, const QPen&, const QBrush&, 
                              const std::vector<QPointF>&, double, const QPointF&)> itemFactory,
    ConnectionManager* connectionManager,
    ConnectionPointOverlay* connectionOverlay,
    SelectionManager* selectionManager) {
    
    qint32 itemCount;
    stream >> itemCount;
    Logger::debug(QString("FileFormatManager::deserializeGraphicItems: 开始反序列化，共%1个图元").arg(itemCount));
    
    QHash<QUuid, FlowchartBaseItem*> itemMap;
    
    // 第一阶段：创建所有图形项（但不解析连接）
    for (qint32 i = 0; i < itemCount; ++i) {
        int storedType;
        qint64 oldPos = stream.device()->pos();
        stream >> storedType;
        stream.device()->seek(oldPos);
        
        Logger::debug(QString("FileFormatManager::deserializeGraphicItems: 处理第%1个图元，类型=%2").arg(i).arg(storedType));
        
        GraphicItem* item = itemFactory(static_cast<Graphic::GraphicType>(storedType), 
                                       QPointF(), QPen(), QBrush(), std::vector<QPointF>(), 0.0, QPointF(1,1));
        if (item) {
            Logger::debug(QString("FileFormatManager::deserializeGraphicItems: 创建图元成功，开始反序列化"));
            item->deserialize(stream);
            scene->addItem(item);
            
            // 收集所有流程图元素的UUID映射
            if (auto* flowchartItem = dynamic_cast<FlowchartBaseItem*>(item)) {
                itemMap[flowchartItem->uuid()] = flowchartItem;
            }
        } else {
            Logger::debug(QString("FileFormatManager::deserializeGraphicItems: 创建图元失败，跳过"));
            skipOneGraphicItem(stream);
        }
    }
    
    // 第二阶段：注册所有流程图元素
    Logger::debug("FileFormatManager::deserializeGraphicItems: 开始注册流程图元素");
    for (auto* item : scene->items()) {
        if (auto* flowchartItem = dynamic_cast<FlowchartBaseItem*>(item)) {
            if (connectionManager) {
                connectionManager->registerFlowchartItem(flowchartItem);
                Logger::debug(QString("FileFormatManager::deserializeGraphicItems: 注册流程图元素到ConnectionManager，UUID=%1")
                    .arg(flowchartItem->uuid().toString()));
            }
        }
    }
    
    // 第三阶段：解析连接关系
    Logger::debug("FileFormatManager::deserializeGraphicItems: 开始解析连接关系");
    for (auto* item : scene->items()) {
        if (auto* connector = dynamic_cast<FlowchartConnectorItem*>(item)) {
            if (connector->needsConnectionResolution()) {
                Logger::debug(QString("FileFormatManager::deserializeGraphicItems: 解析连接关系，UUID=%1")
                    .arg(connector->uuid().toString()));
                connector->resolveConnections(itemMap);
            }
        }
    }
    
    Logger::debug(QString("FileFormatManager::deserializeGraphicItems: 反序列化完成，流状态=%1").arg(stream.status()));
    return stream.status() == QDataStream::Ok;
}

// 序列化图层信息
bool FileFormatManager::serializeLayers(QDataStream& stream, QGraphicsScene* scene) {
    // 在当前版本中，我们只简单地保存Z顺序
    // 未来可以扩展支持真正的图层功能
    
    // 写入图层数量（目前为1，表示无图层）
    stream << (qint32)1;
    
    return stream.status() == QDataStream::Ok;
}

// 反序列化图层信息
bool FileFormatManager::deserializeLayers(QDataStream& stream, QGraphicsScene* scene) {
    // 读取图层数量
    qint32 layerCount;
    stream >> layerCount;
    
    // 目前不做任何特殊处理，因为我们只有一个图层
    
    return stream.status() == QDataStream::Ok;
} 